[合集 - Coding with Grandma(6)](https://github.com)

[1.奶奶都能看懂的 CSS 选择器基础语法&常用属性&优先级02-07](https://github.com/samhou/p/18702767/coding-with-grandma-css-basic)[2.手把手 CSS 盒子模型——从零开始的奶奶级 Web 开发教程206-10](https://github.com/samhou/p/18922690/coding-with-grandma-box-model)[3.手把手 Flexbox——从零开始的奶奶级 Web 开发教程306-15](https://github.com/samhou/p/18929792/coding-with-grandma-flexbox)[4.奶奶都能看懂的 C++ —— 手把手指针10-17](https://github.com/samhou/p/19148878/cpp-pointer-guide):[橘子云加速器](https://meibokele.com)[5.奶奶都能看懂的 C++ —— const 限定符与指针10-19](https://github.com/samhou/p/19150553/cpp-pointer-const-guide)

6.奶奶都能看懂的 C++ —— vector 与迭代器10-25

收起

迭代器 (iterator)，顾名思义就是能够遍历一组对象的东西。

但是在讲解它之前，我们需要先了解迭代的对象是什么。常见的一种，叫做 `vector`。

## vector 类型

### 使用可变有序序列

我们知道，数学里，`vector` 是向量的意思。但 C++ 里的向量和它不太一样。它的含义是，**具有可变元素个数的有序对象序列**。

之所以这里说的是**对象**序列，是因为 vector 可以存储**任意类型**的对象（我们通常称之为，**泛型**，即广泛的类型）。

```
#include  //先引入一下
vector<int> v;
vector v2;
vector<double> v3;
```

看看上面的代码，这下看懂了。先声明 `vector`，再用尖括号包裹 vector 存储的数据类型。

OK 现在我们有了空的对象序列。是时候向其中存入元素了。

```
int i = 10;
v.push_back(i);
```

使用 `.push_back()`，允许我们向对象序列的**末尾**加入元素。由于它是可变长度的，所以可以随意加入对象。

有一点需要注意，vector 永远不会存储引用。也就是说，它会**创建圆括号中的对象的拷贝**（或者移动该对象）。

你应该已经了解过 `string` 或者 `数组` 了。与它们类似，我们也可以用下标运算符，来获取其中**某个元素的[引用](https://github.com)**（注意下标从 0 开始，且你不能超过已有元素的范围）。比如：

```
v.push_back(i);
...
v[5] = 10; // 修改第 6 个元素
```

要想知道一共有多少元素，避免超出，可以用 `size()`。不过它返回的是 `size_type`，你可以用 `auto` 自动判断类型。

```
auto vsize = v.size(); // 自动判断返回值类型
```

### 初始化问题

我们之前都是先创建空的 `vector`，然后再装入对象。实际上，我们也可以直接初始化 `vector`。

```
vector<int> v1{1, 2}; // 1,2
vector<int> v2(2); // 0,0
vector<int> v3(2,3); // 3,3
```

如上，初始化有花括号（列表初始化）和圆括号（值初始化）两种方式。如果是花括号，那么其中的对象列表就会被加入到 vector 中。比如第一行就初始化了一个包含 2 个数字的 vector。

而如果是圆括号，那么分两种情况：

* 如果只输入一个值，那么它会创建相应大小 vector，然后初始化所有值为对应对象的默认值（对于 int，这是 0）
* 如果输入两个值，那么会把**第二个值***复制*，并根据**第一个值**确定元素个数，填充入 vector。比如第三行，**2 个 3**。

注意，初始化只是创建空白 `vector` 然后**存入**，**并非固定了大小**。也就是说，你还可以继续使用 `push_back()` 加入元素，来扩展其大小。

其实还有个特殊情况。如果花括号内的数据，无法用于初始化一个 vector，那么它会**自动作为圆括号处理**：

```
vector v{2}; // "",""
vector v1{2,"HELLO"}; // "HELLO","HELLO"
```

第一行创建了含有 2 个初始值的 string 对象的 vector，第二行则创建了含有 2 个 "HELLO" 的 string 对象的 vector。

实际上，如果你不需要快速创建多个相同的元素，你没有任何理由去用初始化。你可以创建空的 vector，然后随意动态添加元素。

还有一点需要注意。可以直接把一个 vector 复制到另一个：

```
vector<int> v2;
v2 = v1; //OK
```

## 迭代器

好了，既然我们已经有了一个对象的集合，让我们进入正题吧。

```
vector<int> v1 = {1,2,3,4,5};
for(auto it = v1.begin();it!=v1.end();it++){
    cout<<*it<// 输出一行一个 v1 中的元素
```

等等等，上面的代码有些复杂，我们一点点解释，顺便说明什么是迭代器。

第一行，创建了一个含有 5 个元素的 `vector`。

然后用了一个 `for` 语句——

### 什么是迭代器？

首先是初始化：

```
auto it = v1.begin();
```

这就是我们的主角，迭代器。我们用了自动类型判断，实际上 `it` 的类型是：`vector::iterator`，也就是说，vector 有一个迭代器，而 vector 其中存储的对象是 int 类型的。

嗯，你应该能推测出来，`v1.begin()` 返回的是一个迭代器类型。顾名思义，它返回的是**指向第一个对象的迭代器**。

你或许注意到了**指向**这个词，我们在[指针](https://github.com)那里曾经提到过。比较相似，迭代器也是“**一次指向一个对象**”，只不过该对象**必须存在于一个 vector 中**。

什么意思呢？你可以理解为，迭代器是和一组对象结合使用的“指针”，在一个时刻，指向其中的一个对象。比如上面那行，就创建了指向第一个对象 `1` 的迭代器。

那么这样有什么好处呢？我们先来看 for 的第三部分。

```
it++;
```

居然对一个迭代器用了自增运算符！这就是迭代器和指针的区别了——由于它指向一组对象，所以可以随意调整，让它指向其它对象，只要目标对象存在于组内。

我们之前提到，vector 是有序的，所以才能使用下标运算符。而正是这种有序性，使自增自减成为可能。

**如果增加迭代器，就是让它指向当前对象之后的元素；如果减少迭代器，就是让它指向当前对象之前的元素。**

看看下面的例子：

```
vector<int> v = {233,234,114,432,534};
auto it = v.begin(); // index = 0,*it = 233
it++; // index = 1,*it = 234
it += 2; //index = 3,*it = 432
it -= 3; //index = 0,*it = 233
```

`index` 表示当前指向对象的下标。`*it` 表示指向对象的值。

*先不用管那个星号，我们下面会涉及。*

好的，第二部分：

```
it != v1.end();
```

条件判断，用的是不等号。`v1.end()` 返回的是指向 `vector` 列表**最后一个元素**的**下一地址**的迭代器。（之所以不使用比较符号，是因为并不是所有迭代器都可以比较，但是它们都支持不等号/等号，使用不等号更加通用。）

也就是说，它并不指向任何元素，但是如果你有一个指向最后一个元素的迭代器，那么再加一，就指向该位置。

回忆一下 `for` 的使用方法。当这个不等号条件**不满足**时，大括号内的语句**不会**被执行。即，当完成最后一个元素的处理后（在这个例子里，输出了 `5` 这个数），条件判断为假，循环结束。

综上，上面代码的输出是：

```
1
2
3
4
5
```

也就是说，这样编写代码，允许我们遍历序列中的所有元素，而不会漏掉最后一个。

**注意，任何使用迭代器的场景，都不能涉及更改序列大小，否则迭代器会失效。**（这是因为，vector 大小是动态扩展的，更改大小可能会自动移动位置来保证充足内存空间，导致迭代器指向的序列失效）

### 算术运算

实际上，我们可以计算*指向同一序列*的两个迭代器的**差值**：

```
vector<int> v(10);
auto it = v.begin();
auto it2 = v.end();
cout<// output: 10
```

输出结果是 10。可视化一下，实际上是这样的（数字表示下标）：

![iterator]()

### 解引用

你或许注意到了，我们在上面的代码和注释里里用了同样在指针那一节介绍的 `*` 解引用符。

这是因为，迭代器也和指针一样，指向一个*位置*，用解引用符可以获取**位置对应的对象**。

但是等等。如果你好奇心比较旺盛，可能会尝试这个：

```
cout<// Error
cout<<*it<
```

> 你看，我不解引用，不就能看看迭代器指向对象的地址了吗？

然而现实是，这个第一行无法通过编译。

为什么？因为迭代器不是指针，而是一个其它的类型。它只是和指针很像罢了。你可以认为它指向一个地址，从而可以使用解引用运算符，但是你不能把它直接当作指针来用。

当然，既然解引用得到的是一个对象，那么当然可以做许多事情：比如调用函数。

但是要小心，注意优先级，你应该先解引用，再调用函数：

```
vector v{"Hello","World"};
auto it = v.begin();
cout << (*it).substr(2) << endl; // output: llo
cout << *it.substr(2) << endl; // Error
```

## 范围 for 语句

上面我们用三个元素的 for 语句，进行了遍历的操作，其实我们可以简化。

```
vector<int> v{1,2,3,4};
for(auto i:v){
    cout<
```

这个语句叫做，`范围 for` 语句。它会一个一个取出序列中的元素。

和迭代器不同，它返回对象并**拷贝赋值**给冒号前的变量（这里是 `i`），而非其本身。即，修改 `i` 时，不会修改 `v` 序列中的任何内容。

如果你想修改，可以把变量创建为引用：

```
vector<int> v{1,2,3,4};
for(auto &i:v){
    i = 3;
}
for(auto i:v){
    cout<// 3 3 3 3
```

如果你不想改，但不想拷贝防止性能损耗，可以创建[常量引用](https://github.com)。

```
for(const auto &i:v){
    cout<// 禁止修改。
}
```

## 不止 vector

我们一直在探讨 `vector`，但实际上，迭代器对于其它的序列也能使用，比如 `string`。你可以在使用的时候，去查一下是否实现了迭代器。写法都一样，这里省略。

那么范围 for 呢？实际上，实现了 `begin` 和 `end` 的类型，都是可以使用的，满足以下条件即可：

* begin,end 返回的是一个迭代器
* 迭代器可以自增

也就是说，范围 for 只是一种缩写，只要能用迭代器，就能用。在遍历时推荐使用，可以使代码更易读。

好了，这就是 vector 和迭代器的全部内容，我们下次再继续拆解 C++，奶奶级。
